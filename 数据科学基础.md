# 成绩衡量

## 成绩分析的基本假设

1. 题目的难度不因做题同学的变化而变化
2. 学生的代码能力不受题目难度的影响

## 数据类型

我们可以得到

* 修正后的学生成绩(以下内容中的成绩均指修正后的成绩)
  * 分布范围在$[0,100]$，对于使用非python的作答，我们视其为$0$
  * 成绩剔除了面向用例作答的分数
* 程序的运行时间(ms)
* 代码行数

## 编程能力评估

### 数据处理

#### 得分、时间和行数

**elastic search** 题目-同学

代码的好坏由程序运行时间、代码行数和用例测试得分决定。其中这三个因素对编程能力影响的排名是**得分 > 时间 > 行数**，因此我们可以通过以下式子来对得分进行修正：

$$
score' = score \times\Omega(\frac{time-\mu}{\sigma_1})^{\alpha}\times\Omega(\frac{line-\eta}{\sigma_2})^{\beta}
$$

$$
\Omega(x) = \begin{cases}
1.129 & x>1.29 \\
1+\frac{x}{10} &|x|\le1.29 \\
0.871 & x<-1.29
\end{cases}
$$

其中$\alpha, \beta$分别是程序运行时间、代码行数的权重，我们把它们设为$1.15$和$1.05$，$\sigma_1, \sigma_2$分别是时间、行数的标准差，$\mu,\eta$分别是时间、行数的平均值。我们在修正范围中考虑中间80%的同学，超过范围的对其进行误差截断。

#### 缺省值处理

在修正后的成绩中，会看到较多的0分，可能的因素有

* 来不及做
* 题目太简单不想做
* 面向用例太多被判0
* 不会做，被判0

其中面向用例太多被判$0$是主要原因，为了避免太多的0对数据处理造成影响，我们统一将其认为是无效数据，作为缺失值进行处理，进行可能值插补缺失。

作为一种NMAR的缺失值，我们应当结合同学个人的编程能力和该题的难度进行可能值插值。我们认为，得分和题目难度成反比，和个人编程水平成正比。因此得分是该题得分乘上该同学的初始均分在同学中的分位数。

$$
M_{ij} = AVG()
$$

#### 数据表达

记学生的数量为$m$，题目的数量为$n$，令$M_{ij}$为第$i$个学生第$j$题的成绩。则定义学生的成绩矩阵为$M = [a_{ij}]_{m\times n}$

题目的难度定为一个$n$维向量$Q$，其中$Q_i$是第$i$题的难度。最初，将所有题目的难度定为$1$。

### 能力计算

学生的python能力向量记为$B$，其中第$i$个学生的python能力是$B_i$

**rule** : 越难的题目得分越高，则编程能力越强
$$
B_i = \frac{\Sigma_{t}Q_j \times M_{ij}}{n}
$$

**rule** : 编程能力越极端(很强/很蒻)，题目难度对他的影响越小

$$
Q_j = \frac{1}{n}\Sigma_{t}\frac{b}{1+\frac{|B_i - \bar{B}|}{\sigma}}\times(100-M_{ij})
$$

其中$t$是做了的题目，$b = \int_{-\infin}^{+\infin}\frac{1}{1+\Phi(|x|)}dx$，以保证数据的中心性。

### 能力评估

最终我们得到了每个学生的python能力B，我们定义编程能力最强的同学为$10$，最蒻的同学为$1$，有

$$B' = 1 + \frac{10 - 1}{B_{max}-B_{min}}$$
